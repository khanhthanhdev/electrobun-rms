import { Database } from "bun:sqlite";
import { existsSync, unlinkSync } from "node:fs";
import { join } from "node:path";
import { and, eq, inArray } from "drizzle-orm";
import { getTableConfig, type SQLiteTable } from "drizzle-orm/sqlite-core";
import { DATA_DIR, db, schema } from "../../db";
// biome-ignore lint/performance/noNamespaceImport: required to iterate all table exports.
import * as eventSchema from "../../event-db/schema";

export class ServiceError extends Error {
  status: number;
  constructor(message: string, status: number) {
    super(message);
    this.status = status;
  }
}

export interface ManualEventPayload {
  divisions: number;
  endDate: string;
  eventCode: string;
  eventName: string;
  eventType: number;
  finals?: number;
  region: string;
  startDate: string;
  status?: number;
}

export interface DefaultAccountInfo {
  password: string;
  role: (typeof schema.ROLE_VALUES)[number];
  username: string;
}

export interface ManualEventResult {
  event: {
    code: string;
    name: string;
    type: number;
    status: number;
    finals: number;
    divisions: number;
    start: number;
    end: number;
    region: string;
  };
}

const EVENT_CODE_PATTERN = /^[a-z0-9_]+$/;
const MAX_EVENT_CODE_LENGTH = 4;
const RESERVED_CODES = new Set(["global", "server"]);
const PASSWORD_CHARS = "abcdefghijklmnopqrstuvwxyz0123456789";
const PASSWORD_LENGTH = 10;

type RoleValue = (typeof schema.ROLE_VALUES)[number];

interface AutoGeneratedAccountTemplate {
  count: number;
  role: RoleValue;
  usernamePrefix: string;
}

const AUTO_GENERATED_ACCOUNT_TEMPLATES: AutoGeneratedAccountTemplate[] = [
  { role: "ADMIN", usernamePrefix: "eventadmin", count: 1 },
  { role: "TSO", usernamePrefix: "tso", count: 1 },
  { role: "HEAD_REFEREE", usernamePrefix: "hr", count: 1 },
  { role: "LEAD_INSPECTOR", usernamePrefix: "leadinspector", count: 1 },
  { role: "INSPECTOR", usernamePrefix: "inspector", count: 5 },
  { role: "JUDGE", usernamePrefix: "judge", count: 3 },
  { role: "REFEREE", usernamePrefix: "referee", count: 8 },
];

function assertAutoGeneratedAccountRolesAreConfigured(): void {
  const configuredRoles = new Set(
    AUTO_GENERATED_ACCOUNT_TEMPLATES.map((template) => template.role)
  );
  const missingRoles = schema.ROLE_VALUES.filter(
    (role) => !configuredRoles.has(role)
  );

  if (missingRoles.length > 0) {
    throw new Error(
      `Auto-generated account role config is missing roles: ${missingRoles.join(", ")}`
    );
  }
}

function generatePassword(): string {
  const bytes = crypto.getRandomValues(new Uint8Array(PASSWORD_LENGTH));
  return Array.from(
    bytes,
    (b) => PASSWORD_CHARS[b % PASSWORD_CHARS.length]
  ).join("");
}

function generateEventSchemaSql(): string {
  const statements: string[] = [];

  for (const value of Object.values(eventSchema)) {
    const config = getTableConfig(value as SQLiteTable);
    const columnDefs = config.columns.map((col) => {
      let def = `${col.name} ${col.getSQLType()}`;
      if (col.notNull) {
        def += " NOT NULL";
      }
      if (col.primary) {
        def += " PRIMARY KEY";
      }
      return def;
    });
    statements.push(
      `CREATE TABLE IF NOT EXISTS ${config.name} (\n  ${columnDefs.join(",\n  ")}\n);`
    );
  }

  return statements.join("\n\n");
}

function buildDefaultAccounts(
  eventCode: string
): Array<{ username: string; role: RoleValue }> {
  assertAutoGeneratedAccountRolesAreConfigured();

  const accounts: Array<{ username: string; role: RoleValue }> = [];
  for (const template of AUTO_GENERATED_ACCOUNT_TEMPLATES) {
    if (template.count <= 0) {
      continue;
    }

    if (template.count === 1) {
      accounts.push({
        username: `${eventCode}_${template.usernamePrefix}`,
        role: template.role,
      });
      continue;
    }

    for (let index = 1; index <= template.count; index++) {
      accounts.push({
        username: `${eventCode}_${template.usernamePrefix}${index}`,
        role: template.role,
      });
    }
  }

  return accounts;
}

function cleanupEventDb(dbPath: string): void {
  for (const suffix of ["", "-shm", "-wal"]) {
    const file = `${dbPath}${suffix}`;
    if (existsSync(file)) {
      try {
        unlinkSync(file);
      } catch {
        // best-effort cleanup
      }
    }
  }
}

function assertValidEventCode(eventCode: string): void {
  if (
    !eventCode ||
    eventCode.length > MAX_EVENT_CODE_LENGTH ||
    !EVENT_CODE_PATTERN.test(eventCode)
  ) {
    throw new ServiceError(
      `Event code must be 1-${MAX_EVENT_CODE_LENGTH} lowercase alphanumeric characters or underscores.`,
      400
    );
  }
}

function assertEventExists(eventCode: string): void {
  const [eventRow] = db
    .select({ code: schema.events.code })
    .from(schema.events)
    .where(eq(schema.events.code, eventCode))
    .limit(1)
    .all();

  if (!eventRow) {
    throw new ServiceError(`Event "${eventCode}" was not found.`, 404);
  }
}

function createDefaultAccountsWithPasswords(eventCode: string): Promise<
  Array<{
    hashedPassword: string;
    password: string;
    role: RoleValue;
    username: string;
  }>
> {
  const accountDefs = buildDefaultAccounts(eventCode);
  return Promise.all(
    accountDefs.map(async (account) => {
      const password = generatePassword();
      const hashedPassword = await Bun.password.hash(password, {
        algorithm: "bcrypt",
        cost: 10,
      });
      return { ...account, password, hashedPassword };
    })
  );
}

export async function createManualEvent(
  payload: ManualEventPayload
): Promise<ManualEventResult> {
  const { eventCode, eventName, region, eventType, startDate, endDate } =
    payload;
  const divisions = payload.divisions;
  const finals = payload.finals ?? 0;
  const status = payload.status ?? 1;

  assertValidEventCode(eventCode);

  if (RESERVED_CODES.has(eventCode)) {
    throw new ServiceError(
      `Event code "${eventCode}" is reserved and cannot be used.`,
      400
    );
  }

  const startTs = new Date(startDate).getTime();
  const endTs = new Date(endDate).getTime();

  if (Number.isNaN(startTs) || Number.isNaN(endTs)) {
    throw new ServiceError(
      "startDate and endDate must be valid ISO date strings.",
      400
    );
  }

  if (endTs < startTs) {
    throw new ServiceError("endDate must be on or after startDate.", 400);
  }

  if (divisions <= 0) {
    throw new ServiceError("divisions must be greater than 0.", 400);
  }

  const [existingEvent] = db
    .select({ code: schema.events.code })
    .from(schema.events)
    .where(eq(schema.events.code, eventCode))
    .limit(1)
    .all();

  if (existingEvent) {
    throw new ServiceError(
      `Event with code "${eventCode}" already exists.`,
      409
    );
  }

  const dbPath = join(DATA_DIR, `${eventCode}.db`);

  if (existsSync(dbPath)) {
    throw new ServiceError(
      `Database file for event "${eventCode}" already exists.`,
      409
    );
  }

  const eventSchemaSql = generateEventSchemaSql();

  try {
    const eventDb = new Database(dbPath);
    try {
      eventDb.exec("PRAGMA journal_mode = WAL;");
      eventDb.exec("PRAGMA foreign_keys = ON;");
      eventDb.exec(eventSchemaSql);
    } finally {
      eventDb.close();
    }
  } catch {
    cleanupEventDb(dbPath);
    throw new ServiceError("Failed to initialize event database schema.", 500);
  }

  try {
    const now = Date.now();

    await db.transaction(async (tx) => {
      await tx.insert(schema.events).values({
        code: eventCode,
        name: eventName,
        type: eventType,
        status,
        finals,
        divisions,
        start: startTs,
        end: endTs,
        region,
      });

      await tx.insert(schema.eventLog).values({
        timestamp: now,
        type: "EVENT_CREATED",
        event: eventCode,
        info: `Manual event created: ${eventName}`,
        extra: JSON.stringify({
          defaultAccountsInitialized: false,
        }),
      });
    });

    return {
      event: {
        code: eventCode,
        name: eventName,
        type: eventType,
        status,
        finals,
        divisions,
        start: startTs,
        end: endTs,
        region,
      },
    };
  } catch (error) {
    cleanupEventDb(dbPath);
    throw error;
  }
}

export async function regenerateEventDefaultAccounts(
  eventCode: string
): Promise<{
  eventCode: string;
  accounts: DefaultAccountInfo[];
}> {
  assertValidEventCode(eventCode);
  assertEventExists(eventCode);

  const now = Date.now();
  const accountsWithPasswords =
    await createDefaultAccountsWithPasswords(eventCode);
  const defaultUsernames = accountsWithPasswords.map(
    (account) => account.username
  );

  await db.transaction(async (tx) => {
    const existingEventRoleRows = await tx
      .select({ username: schema.roles.username })
      .from(schema.roles)
      .where(eq(schema.roles.event, eventCode))
      .all();

    const existingEventSecretRows = await tx
      .select({ username: schema.accountSecrets.username })
      .from(schema.accountSecrets)
      .where(eq(schema.accountSecrets.event, eventCode))
      .all();

    const usernamesToCleanup = Array.from(
      new Set([
        ...defaultUsernames,
        ...existingEventRoleRows.map((row) => row.username),
        ...existingEventSecretRows.map((row) => row.username),
      ])
    );

    await tx
      .delete(schema.accountSecrets)
      .where(eq(schema.accountSecrets.event, eventCode));

    await tx.delete(schema.roles).where(eq(schema.roles.event, eventCode));

    const remainingRoleRows =
      usernamesToCleanup.length === 0
        ? []
        : await tx
            .select({ username: schema.roles.username })
            .from(schema.roles)
            .where(inArray(schema.roles.username, usernamesToCleanup))
            .all();

    const usernamesWithRemainingRoles = new Set(
      remainingRoleRows.map((row) => row.username)
    );
    const conflictingDefaultUsernames = defaultUsernames.filter((username) =>
      usernamesWithRemainingRoles.has(username)
    );

    if (conflictingDefaultUsernames.length > 0) {
      throw new ServiceError(
        `Cannot regenerate default accounts because these usernames are assigned outside "${eventCode}": ${conflictingDefaultUsernames.join(", ")}.`,
        409
      );
    }

    const usernamesToDelete = usernamesToCleanup.filter(
      (username) => !usernamesWithRemainingRoles.has(username)
    );
    if (usernamesToDelete.length > 0) {
      await tx
        .delete(schema.users)
        .where(inArray(schema.users.username, usernamesToDelete));
    }

    await tx.insert(schema.users).values(
      accountsWithPasswords.map((account) => ({
        username: account.username,
        hashedPassword: account.hashedPassword,
        type: 0,
        used: true,
        generic: true,
      }))
    );

    await tx.insert(schema.roles).values(
      accountsWithPasswords.map((account) => ({
        username: account.username,
        role: account.role,
        event: eventCode,
      }))
    );

    await tx.insert(schema.accountSecrets).values(
      accountsWithPasswords.map((account) => ({
        username: account.username,
        event: eventCode,
        secret: account.password,
        createdAt: now,
      }))
    );

    await tx.insert(schema.eventLog).values({
      timestamp: now,
      type: "DEFAULT_ACCOUNTS_REGENERATED",
      event: eventCode,
      info: `Default accounts regenerated for event "${eventCode}"`,
      extra: JSON.stringify({
        deletedAccounts: usernamesToDelete,
        regeneratedAccounts: accountsWithPasswords.map(
          (account) => account.username
        ),
      }),
    });
  });

  return {
    eventCode,
    accounts: accountsWithPasswords.map((account) => ({
      username: account.username,
      role: account.role,
      password: account.password,
    })),
  };
}

export function getDefaultAccounts(eventCode: string): {
  eventCode: string;
  accounts: DefaultAccountInfo[];
} {
  assertValidEventCode(eventCode);
  assertEventExists(eventCode);

  const rows = db
    .select({
      username: schema.accountSecrets.username,
      secret: schema.accountSecrets.secret,
      role: schema.roles.role,
    })
    .from(schema.accountSecrets)
    .innerJoin(
      schema.roles,
      and(
        eq(schema.accountSecrets.username, schema.roles.username),
        eq(schema.accountSecrets.event, schema.roles.event)
      )
    )
    .where(eq(schema.accountSecrets.event, eventCode))
    .all();

  return {
    eventCode,
    accounts: rows.map((r) => ({
      username: r.username,
      role: r.role as RoleValue,
      password: r.secret,
    })),
  };
}
