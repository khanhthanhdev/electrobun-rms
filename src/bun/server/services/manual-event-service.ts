import { Database } from "bun:sqlite";
import { existsSync, unlinkSync } from "node:fs";
import { join } from "node:path";
import { and, eq } from "drizzle-orm";
import { getTableConfig, type SQLiteTable } from "drizzle-orm/sqlite-core";
import { DATA_DIR, db, schema } from "../../db";
// biome-ignore lint/performance/noNamespaceImport: required to iterate all table exports.
import * as eventSchema from "../../event-db/schema";

export class ServiceError extends Error {
  status: number;
  constructor(message: string, status: number) {
    super(message);
    this.status = status;
  }
}

export interface ManualEventPayload {
  divisions: number;
  endDate: string;
  eventCode: string;
  eventName: string;
  eventType: number;
  finals?: number;
  region: string;
  startDate: string;
  status?: number;
}

export interface DefaultAccountInfo {
  password: string;
  role: (typeof schema.ROLE_VALUES)[number];
  username: string;
}

export interface ManualEventResult {
  defaultAccounts: DefaultAccountInfo[];
  event: {
    code: string;
    name: string;
    type: number;
    status: number;
    finals: number;
    divisions: number;
    start: number;
    end: number;
    region: string;
  };
}

const EVENT_CODE_PATTERN = /^[a-z0-9_]+$/;
const MAX_EVENT_CODE_LENGTH = 4;
const RESERVED_CODES = new Set(["global", "server"]);
const PASSWORD_CHARS = "abcdefghijklmnopqrstuvwxyz0123456789";
const PASSWORD_LENGTH = 10;

type RoleValue = (typeof schema.ROLE_VALUES)[number];

interface AutoGeneratedAccountTemplate {
  count: number;
  role: RoleValue;
  usernamePrefix: string;
}

const AUTO_GENERATED_ACCOUNT_TEMPLATES: AutoGeneratedAccountTemplate[] = [
  { role: "ADMIN", usernamePrefix: "eventadmin", count: 1 },
  { role: "TSO", usernamePrefix: "tso", count: 1 },
  { role: "HEAD_REFEREE", usernamePrefix: "hr", count: 1 },
  { role: "LEAD_INSPECTOR", usernamePrefix: "leadinspector", count: 1 },
  { role: "INSPECTOR", usernamePrefix: "inspector", count: 5 },
  { role: "JUDGE", usernamePrefix: "judge", count: 3 },
  { role: "REFEREE", usernamePrefix: "referee", count: 8 },
];

function assertAutoGeneratedAccountRolesAreConfigured(): void {
  const configuredRoles = new Set(
    AUTO_GENERATED_ACCOUNT_TEMPLATES.map((template) => template.role)
  );
  const missingRoles = schema.ROLE_VALUES.filter(
    (role) => !configuredRoles.has(role)
  );

  if (missingRoles.length > 0) {
    throw new Error(
      `Auto-generated account role config is missing roles: ${missingRoles.join(", ")}`
    );
  }
}

function generatePassword(): string {
  const bytes = crypto.getRandomValues(new Uint8Array(PASSWORD_LENGTH));
  return Array.from(
    bytes,
    (b) => PASSWORD_CHARS[b % PASSWORD_CHARS.length]
  ).join("");
}

function generateEventSchemaSql(): string {
  const statements: string[] = [];

  for (const value of Object.values(eventSchema)) {
    const config = getTableConfig(value as SQLiteTable);
    const columnDefs = config.columns.map((col) => {
      let def = `${col.name} ${col.getSQLType()}`;
      if (col.notNull) {
        def += " NOT NULL";
      }
      if (col.primary) {
        def += " PRIMARY KEY";
      }
      return def;
    });
    statements.push(
      `CREATE TABLE IF NOT EXISTS ${config.name} (\n  ${columnDefs.join(",\n  ")}\n);`
    );
  }

  return statements.join("\n\n");
}

function buildDefaultAccounts(
  eventCode: string
): Array<{ username: string; role: RoleValue }> {
  assertAutoGeneratedAccountRolesAreConfigured();

  const accounts: Array<{ username: string; role: RoleValue }> = [];
  for (const template of AUTO_GENERATED_ACCOUNT_TEMPLATES) {
    if (template.count <= 0) {
      continue;
    }

    if (template.count === 1) {
      accounts.push({
        username: `${eventCode}_${template.usernamePrefix}`,
        role: template.role,
      });
      continue;
    }

    for (let index = 1; index <= template.count; index++) {
      accounts.push({
        username: `${eventCode}_${template.usernamePrefix}${index}`,
        role: template.role,
      });
    }
  }

  return accounts;
}

function cleanupEventDb(dbPath: string): void {
  for (const suffix of ["", "-shm", "-wal"]) {
    const file = `${dbPath}${suffix}`;
    if (existsSync(file)) {
      try {
        unlinkSync(file);
      } catch {
        // best-effort cleanup
      }
    }
  }
}

export async function createManualEvent(
  payload: ManualEventPayload
): Promise<ManualEventResult> {
  const { eventCode, eventName, region, eventType, startDate, endDate } =
    payload;
  const divisions = payload.divisions;
  const finals = payload.finals ?? 0;
  const status = payload.status ?? 1;

  if (
    !eventCode ||
    eventCode.length > MAX_EVENT_CODE_LENGTH ||
    !EVENT_CODE_PATTERN.test(eventCode)
  ) {
    throw new ServiceError(
      `Event code must be 1-${MAX_EVENT_CODE_LENGTH} lowercase alphanumeric characters or underscores.`,
      400
    );
  }

  if (RESERVED_CODES.has(eventCode)) {
    throw new ServiceError(
      `Event code "${eventCode}" is reserved and cannot be used.`,
      400
    );
  }

  const startTs = new Date(startDate).getTime();
  const endTs = new Date(endDate).getTime();

  if (Number.isNaN(startTs) || Number.isNaN(endTs)) {
    throw new ServiceError(
      "startDate and endDate must be valid ISO date strings.",
      400
    );
  }

  if (endTs < startTs) {
    throw new ServiceError("endDate must be on or after startDate.", 400);
  }

  if (divisions <= 0) {
    throw new ServiceError("divisions must be greater than 0.", 400);
  }

  const [existingEvent] = db
    .select({ code: schema.events.code })
    .from(schema.events)
    .where(eq(schema.events.code, eventCode))
    .limit(1)
    .all();

  if (existingEvent) {
    throw new ServiceError(
      `Event with code "${eventCode}" already exists.`,
      409
    );
  }

  const dbPath = join(DATA_DIR, `${eventCode}.db`);

  if (existsSync(dbPath)) {
    throw new ServiceError(
      `Database file for event "${eventCode}" already exists.`,
      409
    );
  }

  const eventSchemaSql = generateEventSchemaSql();

  try {
    const eventDb = new Database(dbPath);
    try {
      eventDb.exec("PRAGMA journal_mode = WAL;");
      eventDb.exec("PRAGMA foreign_keys = ON;");
      eventDb.exec(eventSchemaSql);
    } finally {
      eventDb.close();
    }
  } catch {
    cleanupEventDb(dbPath);
    throw new ServiceError("Failed to initialize event database schema.", 500);
  }

  try {
    const accountDefs = buildDefaultAccounts(eventCode);
    const now = Date.now();

    const accountsWithPasswords = await Promise.all(
      accountDefs.map(async (account) => {
        const password = generatePassword();
        const hashedPassword = await Bun.password.hash(password, {
          algorithm: "bcrypt",
          cost: 10,
        });
        return { ...account, password, hashedPassword };
      })
    );

    await db.transaction(async (tx) => {
      await tx.insert(schema.events).values({
        code: eventCode,
        name: eventName,
        type: eventType,
        status,
        finals,
        divisions,
        start: startTs,
        end: endTs,
        region,
      });

      await tx.insert(schema.users).values(
        accountsWithPasswords.map((a) => ({
          username: a.username,
          hashedPassword: a.hashedPassword,
          type: 0,
          used: true,
          generic: true,
        }))
      );

      await tx.insert(schema.roles).values(
        accountsWithPasswords.map((a) => ({
          username: a.username,
          role: a.role,
          event: eventCode,
        }))
      );

      await tx.insert(schema.accountSecrets).values(
        accountsWithPasswords.map((a) => ({
          username: a.username,
          event: eventCode,
          secret: a.password,
          createdAt: now,
        }))
      );

      await tx.insert(schema.eventLog).values({
        timestamp: now,
        type: "EVENT_CREATED",
        event: eventCode,
        info: `Manual event created: ${eventName}`,
        extra: JSON.stringify({
          accounts: accountsWithPasswords.map((a) => a.username),
        }),
      });
    });

    return {
      event: {
        code: eventCode,
        name: eventName,
        type: eventType,
        status,
        finals,
        divisions,
        start: startTs,
        end: endTs,
        region,
      },
      defaultAccounts: accountsWithPasswords.map((a) => ({
        username: a.username,
        role: a.role,
        password: a.password,
      })),
    };
  } catch (error) {
    cleanupEventDb(dbPath);
    throw error;
  }
}

export function getDefaultAccounts(eventCode: string): {
  eventCode: string;
  accounts: DefaultAccountInfo[];
} {
  if (
    !eventCode ||
    eventCode.length > MAX_EVENT_CODE_LENGTH ||
    !EVENT_CODE_PATTERN.test(eventCode)
  ) {
    throw new ServiceError(
      `Event code must be 1-${MAX_EVENT_CODE_LENGTH} lowercase alphanumeric characters or underscores.`,
      400
    );
  }

  const [eventRow] = db
    .select({ code: schema.events.code })
    .from(schema.events)
    .where(eq(schema.events.code, eventCode))
    .limit(1)
    .all();

  if (!eventRow) {
    throw new ServiceError(`Event "${eventCode}" was not found.`, 404);
  }

  const rows = db
    .select({
      username: schema.accountSecrets.username,
      secret: schema.accountSecrets.secret,
      role: schema.roles.role,
    })
    .from(schema.accountSecrets)
    .innerJoin(
      schema.roles,
      and(
        eq(schema.accountSecrets.username, schema.roles.username),
        eq(schema.accountSecrets.event, schema.roles.event)
      )
    )
    .where(eq(schema.accountSecrets.event, eventCode))
    .all();

  if (rows.length === 0) {
    throw new ServiceError(
      `Default accounts for event "${eventCode}" were not found.`,
      404
    );
  }

  return {
    eventCode,
    accounts: rows.map((r) => ({
      username: r.username,
      role: r.role as RoleValue,
      password: r.secret,
    })),
  };
}
